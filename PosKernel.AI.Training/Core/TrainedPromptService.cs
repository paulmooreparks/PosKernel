/*
Copyright 2025 Paul Moore Parks and contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

using Microsoft.Extensions.Logging;
using PosKernel.AI.Training.Storage;
using PosKernel.AI.Services;
using PosKernel.AI.Models;

namespace PosKernel.AI.Training.Core;

/// <summary>
/// Prompt management service that integrates with existing PosKernel.AI personality system
/// ARCHITECTURAL PRINCIPLE: Uses production AI infrastructure instead of separate storage
/// </summary>
public class PromptManagementService : IPromptManagementService
{
    private readonly ITrainingDataStore _dataStore;
    private readonly ILogger<PromptManagementService> _logger;
    
    // Storage keys
    private const string PROMPT_HISTORY_KEY_PREFIX = "prompt-history";
    private const string PROMPT_BACKUP_KEY_PREFIX = "prompt-backup";

    public PromptManagementService(
        ITrainingDataStore dataStore,
        ILogger<PromptManagementService> logger)
    {
        _dataStore = dataStore ?? throw new ArgumentNullException(nameof(dataStore));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<string> GetCurrentPromptAsync(PersonalityType personalityType, string promptType, PromptContext context)
    {
        try
        {
            // Use existing AiPersonalityFactory to get current production prompt
            var prompt = AiPersonalityFactory.BuildPrompt(personalityType, promptType, context);
            
            if (string.IsNullOrEmpty(prompt))
            {
                throw new InvalidOperationException(
                    $"DESIGN DEFICIENCY: No prompt found for personality {personalityType}, type {promptType}. " +
                    $"Check that prompt file exists: {personalityType}/{promptType}.md");
            }

            _logger.LogDebug("Retrieved current prompt for {PersonalityType}/{PromptType}: {Length} characters", 
                personalityType, promptType, prompt.Length);
            
            return prompt;
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException(
                $"DESIGN DEFICIENCY: Failed to get current prompt for {personalityType}/{promptType}. " +
                $"Check AiPersonalityFactory configuration and prompt files. Error: {ex.Message}");
        }
    }

    public async Task SaveOptimizedPromptAsync(PersonalityType personalityType, string promptType, string optimizedPrompt, double performanceScore, string trainingSessionId)
    {
        if (string.IsNullOrEmpty(optimizedPrompt))
        {
            throw new ArgumentException("Optimized prompt cannot be null or empty", nameof(optimizedPrompt));
        }

        try
        {
            // Get current prompt for comparison
            var context = new PromptContext 
            { 
                TimeOfDay = "afternoon", 
                CurrentTime = DateTime.Now.ToString("HH:mm") 
            };
            
            var currentPrompt = await GetCurrentPromptAsync(personalityType, promptType, context);
            
            // Create optimization record
            var optimizationRecord = new PromptOptimizationRecord
            {
                Id = Guid.NewGuid().ToString("N")[..8],
                PersonalityType = personalityType,
                PromptType = promptType,
                OriginalPrompt = currentPrompt,
                OptimizedPrompt = optimizedPrompt,
                PerformanceScore = performanceScore,
                Timestamp = DateTime.UtcNow,
                TrainingSessionId = trainingSessionId,
                QualityMetrics = new Dictionary<string, double>
                {
                    { "PerformanceScore", performanceScore },
                    { "ImprovementRatio", performanceScore > 0.5 ? performanceScore / 0.5 : 0 }
                },
                Notes = $"Generated by training session {trainingSessionId}"
            };

            // Save optimization record to training data store
            var recordKey = GetPromptHistoryKey(personalityType, promptType, optimizationRecord.Id);
            await _dataStore.SaveAsync(recordKey, optimizationRecord);

            // TODO: In Phase 2, integrate with AiPersonalityFactory to actually update production prompts
            // For now, just log what would be done
            _logger.LogInformation("Saved prompt optimization record {RecordId} for {PersonalityType}/{PromptType} with score {Score:F3}", 
                optimizationRecord.Id, personalityType, promptType, performanceScore);
            
            _logger.LogWarning("ARCHITECTURAL TODO: Prompt optimization saved to training store but not yet applied to production. " +
                              "Phase 2 will integrate with AiPersonalityFactory to update actual prompts used by ChatOrchestrator.");
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException(
                $"DESIGN DEFICIENCY: Failed to save optimized prompt for {personalityType}/{promptType}. " +
                $"Check storage accessibility and prompt format. Error: {ex.Message}");
        }
    }

    public async Task<IReadOnlyList<string>> GetAvailablePromptTypesAsync(PersonalityType personalityType)
    {
        try
        {
            // Standard prompt types used by PosKernel.AI ChatOrchestrator
            var standardTypes = new List<string>
            {
                "greeting",
                "ordering", 
                "tool_acknowledgment",
                "payment_complete",
                "next_customer"
            };

            _logger.LogDebug("Retrieved {Count} standard prompt types for {PersonalityType}", 
                standardTypes.Count, personalityType);
            
            return standardTypes;
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException(
                $"DESIGN DEFICIENCY: Failed to get available prompt types for {personalityType}. " +
                $"Check AiPersonalityFactory prompt directory structure. Error: {ex.Message}");
        }
    }

    public async Task<IReadOnlyList<PromptOptimizationRecord>> GetPromptHistoryAsync(PersonalityType personalityType, string promptType, int limit = 10)
    {
        try
        {
            var historyPattern = GetPromptHistoryKeyPattern(personalityType, promptType);
            var historyKeys = await _dataStore.ListKeysAsync(historyPattern);
            
            var records = new List<PromptOptimizationRecord>();
            
            // Get records in parallel for better performance
            var recordTasks = historyKeys.Take(limit).Select(async key =>
            {
                return await _dataStore.LoadAsync<PromptOptimizationRecord>(key);
            });

            var recordResults = await Task.WhenAll(recordTasks);
            
            records.AddRange(recordResults.Where(r => r != null)!);
            
            // Sort by timestamp descending (newest first)
            records.Sort((a, b) => b.Timestamp.CompareTo(a.Timestamp));

            _logger.LogDebug("Retrieved {Count} prompt optimization records for {PersonalityType}/{PromptType}", 
                records.Count, personalityType, promptType);
            
            return records.Take(limit).ToList();
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException(
                $"DESIGN DEFICIENCY: Failed to get prompt history for {personalityType}/{promptType}. " +
                $"Check storage accessibility. Error: {ex.Message}");
        }
    }

    public async Task<PromptTestResult> TestPromptVariantAsync(PersonalityType personalityType, string promptType, string promptVariant, string testScenario)
    {
        try
        {
            // TODO: In Phase 2, integrate with real ChatOrchestrator to test prompts against production system
            // For now, return mock test result
            var mockResult = new PromptTestResult
            {
                IsSuccessful = true,
                ResponseQuality = 0.75 + new Random().NextDouble() * 0.2, // 0.75-0.95 range
                ActualResponse = $"Mock AI response for scenario: {testScenario}",
                ResponseTime = TimeSpan.FromMilliseconds(500 + new Random().Next(1000)),
                QualityMetrics = new Dictionary<string, double>
                {
                    { "Relevance", 0.8 + new Random().NextDouble() * 0.2 },
                    { "PersonalityAlignment", 0.75 + new Random().NextDouble() * 0.25 },
                    { "ActionAccuracy", 0.7 + new Random().NextDouble() * 0.3 }
                }
            };

            _logger.LogDebug("Tested prompt variant for {PersonalityType}/{PromptType}: Quality={Quality:F3}", 
                personalityType, promptType, mockResult.ResponseQuality);
            
            _logger.LogWarning("ARCHITECTURAL TODO: Using mock prompt testing. " +
                              "Phase 2 will integrate with real ChatOrchestrator and OpenAI to test actual prompt variants.");
            
            return await Task.FromResult(mockResult);
        }
        catch (Exception ex)
        {
            return new PromptTestResult
            {
                IsSuccessful = false,
                ResponseQuality = 0.0,
                ActualResponse = "",
                ResponseTime = TimeSpan.Zero,
                QualityMetrics = new Dictionary<string, double>(),
                ErrorMessage = ex.Message
            };
        }
    }

    private static string GetPromptHistoryKey(PersonalityType personalityType, string promptType, string recordId) 
        => $"{PROMPT_HISTORY_KEY_PREFIX}-{personalityType}-{promptType}-{recordId}";

    private static string GetPromptHistoryKeyPattern(PersonalityType personalityType, string promptType) 
        => $"{PROMPT_HISTORY_KEY_PREFIX}-{personalityType}-{promptType}*";
}
